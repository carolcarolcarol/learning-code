// 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

// 示例:

// 输入: [-2,1,-3,4,-1,2,1,-5,4],
// 输出: 6
// 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
// 进阶:

// 如果你已经实现复杂度为 O(n) 的解法，尝试使用更为精妙的分治法求解。


/**
 * @param {number[]} nums
 * @return {number}
 */
var maxSubArray = function(nums) {

    let pre = 0, maxAns = nums[0];
    nums.forEach((x) => {
        pre = Math.max(pre + x, x);//遍历到当前位的数字之和，与当前位置的数字相比较
        //pre为两数中较大的那一个，如果都是正数，那肯定取pre+x
        //如果当前数之前的数字都为负数,而x为正数，那么pre+x的值一定小于x的值，那么就取x
        //这样可以不取负数的和
        //不写成pre=pre+x的原因是,如果前面为负数，当前位置为正数，那么应该不加负数，
        //只取正数，所以需要遍历到当前位置的数字之和，与当前位置的数字相比较，如果之前有负数，则不取负数
        //pre+x,pre用于判断是否加到了负数，
        //只加正数这个操作是由maxAns,pre完成的，
        //如果加到了负数，那么当前的pre（遍历到当前位置的数字之和）一定是小于
        //上一次的maxAns的（没加负数之前的和）
        //所以会选择上一次作为最大值，以此保证不加负数，只加正数
        

        maxAns = Math.max(maxAns, pre);//前一次数字之和和这一次数字之和相比较，选大的那一位
    });
    return maxAns;
};